const passport = require('passport')
const LocalStrategy = require('passport-local').Strategy

// import Facebook login strategy
const FacebookStrategy = require('passport-facebook').Strategy

// import bcrypt
const bcrypt = require('bcryptjs')

// import User model
const User = require('../models/user')

module.exports = app => {
  // initialize Passport middleware
  app.use(passport.initialize())
  app.use(passport.session())

  // set LocalStrategy
  const customFields = {
    // make default verify username to account
    usernameField: 'account',
    // passwordField: 'pw',
    passReqToCallback: true
  }
  const verifyCallback = async (req, account, password, done) => {
    try {
      const user = await User.findOne({ account })
      if (user === null) { // account not exist

        req.flash('wrongAccont', account) // keep account in field of views/login.hbs
        req.flash('wrongPasswd', password) // keep password in field of views/login.hbs

        return done(null, false, { message: 'The Account is not registered!' })
        // if first parameter of done() = error => cant reach Database or something wrong
        // if first parameter = null => reach Database successfully
        // if second parameter = false => cant find document in Database
        // third parameter is for warning message
      } else {
        // user.password is a hashed passwd in Database
        // password is raw, not hashed
        // cant compare using ===, need to use bcrypt.compare()
        const isValid = await bcrypt.compare(password, user.password)

        if (!isValid) { // wrong password

          req.flash('wrongAccont', account) // keep account in field of views/login.hbs
          req.flash('wrongPasswd', password) // keep password in field of views/login.hbs

          return done(null, false, { message: 'The Password is incorrect.' })
        } else {
          return done(null, user)
          // if second parameter = user => find document successfully
        }

      }
    } catch (error) {
      return done(error)
    }
  }
  const localStrategy = new LocalStrategy(customFields, verifyCallback)
  passport.use(localStrategy)

  // set FacebookStrategy
  passport.use(new FacebookStrategy(
    {
      clientID: process.env.FACEBOOK_APP_ID,
      clientSecret: process.env.FACEBOOK_APP_SECRET,
      callbackURL: process.env.FACEBOOK_CALLBACK,
      profileFields: ['email', 'displayName']
      // fields that ask Facebook to provide
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        const { name, email } = profile._json
        const user = await User.findOne({ account: email })
        if (user === null) { // account not exist
          // register a new account
          // account = Facebook email
          // so we need to gen password
          const randomPassword = Math.random().toString(36).slice(-8)
          // gen 8 digits random number
          const salt = await bcrypt.genSalt(10) // saltRounds = 10
          const hash = await bcrypt.hash(randomPassword, salt)

          const newUser = await User.create(
            {
              name,
              account: email,
              password: hash, // use hash replace password
              totalAmount: 0,
              categoryAmount: [0, 0, 0, 0, 0, 0]
            }
          )
          return done(null, newUser)
        } else { // account exist, return user
          return done(null, user)
        }
      } catch (error) {
        return done(error)
      }
    }
  ))

  // set serialize, transform user into user._id
  passport.serializeUser((user, done) => {
    // second parameter user._id is automatically generated by MongoDB 
    done(null, user._id)
  })

  // set deserialize, transform _id into user
  passport.deserializeUser((_id, done) => {
    User.findById(_id)
      .lean()
      .then(user => done(null, user))
      .catch(error => done(error))
  })
}
